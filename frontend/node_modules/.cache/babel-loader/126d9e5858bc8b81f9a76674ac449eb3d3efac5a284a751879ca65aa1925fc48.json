{"ast":null,"code":"'use strict';\n\nconst FieldFlags = require('../constants/field_flags.js');\nconst Charsets = require('../constants/charsets.js');\nconst Types = require('../constants/types.js');\nconst helpers = require('../helpers');\nconst genFunc = require('generate-function');\nconst parserCache = require('./parser_cache.js');\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\nfunction readCodeFor(field, config, options, fieldNum) {\n  const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);\n  const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n  const unsigned = field.flags & FieldFlags.UNSIGNED;\n  switch (field.columnType) {\n    case Types.TINY:\n      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';\n    case Types.SHORT:\n      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';\n    case Types.LONG:\n    case Types.INT24:\n      // in binary protocol int24 is encoded in 4 bytes int32\n      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';\n    case Types.YEAR:\n      return 'packet.readInt16()';\n    case Types.FLOAT:\n      return 'packet.readFloat();';\n    case Types.DOUBLE:\n      return 'packet.readDouble();';\n    case Types.NULL:\n      return 'null;';\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n    case Types.NEWDATE:\n      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {\n        return `packet.readDateTimeString(${parseInt(field.decimals, 10)});`;\n      }\n      return `packet.readDateTime(${helpers.srcEscape(timezone)});`;\n    case Types.TIME:\n      return 'packet.readTimeString()';\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat();';\n      }\n      return 'packet.readLengthCodedString(\"ascii\");';\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue();';\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return config.jsonStrings ? 'packet.readLengthCodedString(\"utf8\")' : 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';\n    case Types.LONGLONG:\n      if (!supportBigNumbers) {\n        return unsigned ? 'packet.readInt64JSNumber();' : 'packet.readSInt64JSNumber();';\n      }\n      if (bigNumberStrings) {\n        return unsigned ? 'packet.readInt64String();' : 'packet.readSInt64String();';\n      }\n      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';\n    default:\n      if (field.characterSet === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer();';\n      }\n      return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;\n  }\n}\nfunction compile(fields, options, config) {\n  const parserFn = genFunc();\n  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n  function wrap(field, packet) {\n    return {\n      type: typeNames[field.columnType],\n      length: field.columnLength,\n      db: field.schema,\n      table: field.table,\n      name: field.name,\n      string: function (encoding = field.encoding) {\n        if (field.columnType === Types.JSON && encoding === field.encoding) {\n          // Since for JSON columns mysql always returns charset 63 (BINARY),\n          // we have to handle it according to JSON specs and use \"utf8\",\n          // see https://github.com/sidorares/node-mysql2/issues/1661\n          console.warn(`typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``);\n        }\n        return packet.readLengthCodedString(encoding);\n      },\n      buffer: function () {\n        return packet.readLengthCodedBuffer();\n      },\n      geometry: function () {\n        return packet.parseGeometryValue();\n      }\n    };\n  }\n  parserFn('(function(){');\n  parserFn('return class BinaryRow {');\n  parserFn('constructor() {');\n  parserFn('}');\n  parserFn('next(packet, fields, options) {');\n  if (options.rowsAsArray) {\n    parserFn(`const result = new Array(${fields.length});`);\n  } else {\n    parserFn('const result = {};');\n  }\n\n  // Global typeCast\n  if (typeof config.typeCast === 'function' && typeof options.typeCast !== 'function') {\n    options.typeCast = config.typeCast;\n  }\n  parserFn('packet.readInt8();'); // status byte\n  for (let i = 0; i < nullBitmapLength; ++i) {\n    parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);\n  }\n  let lvalue = '';\n  let currentFieldNullBit = 4;\n  let nullByteIndex = 0;\n  let fieldName = '';\n  let tableName = '';\n  for (let i = 0; i < fields.length; i++) {\n    fieldName = helpers.fieldEscape(fields[i].name);\n    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);\n\n    if (typeof options.nestTables === 'string') {\n      lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;\n    } else if (options.nestTables === true) {\n      tableName = helpers.fieldEscape(fields[i].table);\n      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);\n      lvalue = `result[${tableName}][${fieldName}]`;\n    } else if (options.rowsAsArray) {\n      lvalue = `result[${i.toString(10)}]`;\n    } else {\n      lvalue = `result[${fieldName}]`;\n    }\n    parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);\n    parserFn(`${lvalue} = null;`);\n    parserFn('else {');\n    if (options.typeCast === false) {\n      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);\n    } else {\n      const fieldWrapperVar = `fieldWrapper${i}`;\n      parserFn(`const ${fieldWrapperVar} = wrap(fields[${i}], packet);`);\n      const readCode = readCodeFor(fields[i], config, options, i);\n      if (typeof options.typeCast === 'function') {\n        parserFn(`${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`);\n      } else {\n        parserFn(`${lvalue} = ${readCode};`);\n      }\n    }\n    parserFn('}');\n    currentFieldNullBit *= 2;\n    if (currentFieldNullBit === 0x100) {\n      currentFieldNullBit = 1;\n      nullByteIndex++;\n    }\n  }\n  parserFn('return result;');\n  parserFn('}');\n  parserFn('};')('})()');\n  if (config.debug) {\n    helpers.printDebugWithCode('Compiled binary protocol row parser', parserFn.toString());\n  }\n  return parserFn.toFunction({\n    wrap\n  });\n}\nfunction getBinaryParser(fields, options, config) {\n  return parserCache.getParser('binary', fields, options, config, compile);\n}\nmodule.exports = getBinaryParser;","map":{"version":3,"names":["FieldFlags","require","Charsets","Types","helpers","genFunc","parserCache","typeNames","t","readCodeFor","field","config","options","fieldNum","supportBigNumbers","Boolean","bigNumberStrings","timezone","dateStrings","unsigned","flags","UNSIGNED","columnType","TINY","SHORT","LONG","INT24","YEAR","FLOAT","DOUBLE","NULL","DATE","DATETIME","TIMESTAMP","NEWDATE","typeMatch","parseInt","decimals","srcEscape","TIME","DECIMAL","NEWDECIMAL","decimalNumbers","GEOMETRY","JSON","jsonStrings","LONGLONG","characterSet","BINARY","compile","fields","parserFn","nullBitmapLength","Math","floor","length","wrap","packet","type","columnLength","db","schema","table","name","string","encoding","console","warn","readLengthCodedString","buffer","readLengthCodedBuffer","geometry","parseGeometryValue","rowsAsArray","typeCast","i","lvalue","currentFieldNullBit","nullByteIndex","fieldName","tableName","fieldEscape","nestTables","toString","fieldWrapperVar","readCode","debug","printDebugWithCode","toFunction","getBinaryParser","getParser","module","exports"],"sources":["/Users/rifkyroudana/node_modules/mysql2/lib/parsers/binary_parser.js"],"sourcesContent":["'use strict';\n\nconst FieldFlags = require('../constants/field_flags.js');\nconst Charsets = require('../constants/charsets.js');\nconst Types = require('../constants/types.js');\nconst helpers = require('../helpers');\nconst genFunc = require('generate-function');\nconst parserCache = require('./parser_cache.js');\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\n\nfunction readCodeFor(field, config, options, fieldNum) {\n  const supportBigNumbers = Boolean(\n    options.supportBigNumbers || config.supportBigNumbers,\n  );\n  const bigNumberStrings = Boolean(\n    options.bigNumberStrings || config.bigNumberStrings,\n  );\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n  const unsigned = field.flags & FieldFlags.UNSIGNED;\n  switch (field.columnType) {\n    case Types.TINY:\n      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';\n    case Types.SHORT:\n      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';\n    case Types.LONG:\n    case Types.INT24: // in binary protocol int24 is encoded in 4 bytes int32\n      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';\n    case Types.YEAR:\n      return 'packet.readInt16()';\n    case Types.FLOAT:\n      return 'packet.readFloat();';\n    case Types.DOUBLE:\n      return 'packet.readDouble();';\n    case Types.NULL:\n      return 'null;';\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n    case Types.NEWDATE:\n      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {\n        return `packet.readDateTimeString(${parseInt(field.decimals, 10)});`;\n      }\n      return `packet.readDateTime(${helpers.srcEscape(timezone)});`;\n    case Types.TIME:\n      return 'packet.readTimeString()';\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat();';\n      }\n      return 'packet.readLengthCodedString(\"ascii\");';\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue();';\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return config.jsonStrings ? 'packet.readLengthCodedString(\"utf8\")' : 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';\n    case Types.LONGLONG:\n      if (!supportBigNumbers) {\n        return unsigned\n          ? 'packet.readInt64JSNumber();'\n          : 'packet.readSInt64JSNumber();';\n      }\n      if (bigNumberStrings) {\n        return unsigned\n          ? 'packet.readInt64String();'\n          : 'packet.readSInt64String();';\n      }\n      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';\n\n    default:\n      if (field.characterSet === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer();';\n      }\n      return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;\n  }\n}\n\nfunction compile(fields, options, config) {\n  const parserFn = genFunc();\n  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n\n  function wrap(field, packet) {\n    return {\n      type: typeNames[field.columnType],\n      length: field.columnLength,\n      db: field.schema,\n      table: field.table,\n      name: field.name,\n      string: function (encoding = field.encoding) {\n        if (field.columnType === Types.JSON && encoding === field.encoding) {\n          // Since for JSON columns mysql always returns charset 63 (BINARY),\n          // we have to handle it according to JSON specs and use \"utf8\",\n          // see https://github.com/sidorares/node-mysql2/issues/1661\n          console.warn(\n            `typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``,\n          );\n        }\n\n        return packet.readLengthCodedString(encoding);\n      },\n      buffer: function () {\n        return packet.readLengthCodedBuffer();\n      },\n      geometry: function () {\n        return packet.parseGeometryValue();\n      },\n    };\n  }\n\n  parserFn('(function(){');\n  parserFn('return class BinaryRow {');\n  parserFn('constructor() {');\n  parserFn('}');\n\n  parserFn('next(packet, fields, options) {');\n  if (options.rowsAsArray) {\n    parserFn(`const result = new Array(${fields.length});`);\n  } else {\n    parserFn('const result = {};');\n  }\n\n  // Global typeCast\n  if (\n    typeof config.typeCast === 'function' &&\n    typeof options.typeCast !== 'function'\n  ) {\n    options.typeCast = config.typeCast;\n  }\n\n  parserFn('packet.readInt8();'); // status byte\n  for (let i = 0; i < nullBitmapLength; ++i) {\n    parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);\n  }\n\n  let lvalue = '';\n  let currentFieldNullBit = 4;\n  let nullByteIndex = 0;\n  let fieldName = '';\n  let tableName = '';\n\n  for (let i = 0; i < fields.length; i++) {\n    fieldName = helpers.fieldEscape(fields[i].name);\n    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);\n\n    if (typeof options.nestTables === 'string') {\n      lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;\n    } else if (options.nestTables === true) {\n      tableName = helpers.fieldEscape(fields[i].table);\n\n      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);\n      lvalue = `result[${tableName}][${fieldName}]`;\n    } else if (options.rowsAsArray) {\n      lvalue = `result[${i.toString(10)}]`;\n    } else {\n      lvalue = `result[${fieldName}]`;\n    }\n\n    parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);\n    parserFn(`${lvalue} = null;`);\n    parserFn('else {');\n\n    if (options.typeCast === false) {\n      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);\n    } else {\n      const fieldWrapperVar = `fieldWrapper${i}`;\n      parserFn(`const ${fieldWrapperVar} = wrap(fields[${i}], packet);`);\n      const readCode = readCodeFor(fields[i], config, options, i);\n\n      if (typeof options.typeCast === 'function') {\n        parserFn(\n          `${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`,\n        );\n      } else {\n        parserFn(`${lvalue} = ${readCode};`);\n      }\n    }\n    parserFn('}');\n\n    currentFieldNullBit *= 2;\n    if (currentFieldNullBit === 0x100) {\n      currentFieldNullBit = 1;\n      nullByteIndex++;\n    }\n  }\n\n  parserFn('return result;');\n  parserFn('}');\n  parserFn('};')('})()');\n\n  if (config.debug) {\n    helpers.printDebugWithCode(\n      'Compiled binary protocol row parser',\n      parserFn.toString(),\n    );\n  }\n  return parserFn.toFunction({ wrap });\n}\n\nfunction getBinaryParser(fields, options, config) {\n  return parserCache.getParser('binary', fields, options, config, compile);\n}\n\nmodule.exports = getBinaryParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}